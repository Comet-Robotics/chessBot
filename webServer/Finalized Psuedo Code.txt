-- In server.js --
lock clients from making moves before calling sendMove()
Whenever client requests board status, ask bot manager if bots done moving,
and unlock client if they are



-- In BotManager.js --
// A location in 2D space with an x and y coordiante
class Point {
    int x
    int y
}

// A class for a path object that holds the chess piece and relative tile movements
class Path {
    ChessPiece piece
    int horizontal
    int vertical
}



-- In ChessPiece class --
add a Point for location to properties



-- In BotManager class --
bool botsMoving

// Just returns the value of botsMoving (server.js will call this)
bool getStatus() {
    return botsMoving
}

// Takes a position in the form "a2", "d7", etc and converts it into a point object
Point convertStringToPoint(*String stringPoint*) {
    turn stringPoint into int x and int y
    Point point = new Point(x, y)
    return point
}

// Calculates the number of horizontal and vertical tiles to get to destination and returns it
int[] calculatePath(Point from, Point to) {
	Path move
	simple math
	return move
}

// Takes in two points.
// Move the object on the board at *from*'s position to *to*'s position
void updateMatrix(Point from, Point to) {
    board[to.x][to.y] = board[from.x][from.y]
    board[from.x][from.y] = 0
}

// Determine every robot in the way of a path and put them into an array
ChessPiece[] calculateAllCollisions(Path path) {
    ChessPiece[] collisions
    Point start = path.piece.location
    loop through board from start along the path {
        if tile has a bot {
            ChessPiece collider = bot at current board position
            add collider to collisions
        }
    }
    return collisions
}

// Will go down a path to find a new path for every bot until an empty space
// This is only half finished. I suck at recursion lol
void recursiveCalculateCollision(Point from, ChessPiece piece, Path[][] collection) {
    Point next = use *from* to determine where bot needs to move to get out of way
    Path nextPath = calculatePath(piece.location, next)
    add nextPath to collection
    ChessPiece[] collisions = calculateAllCollisions(nextPath)
    // If there are no more collisions, this loop won't run, and recursion stops
    loop through collisions -> currentCollision {
        recursiveCalculateCollision(from, currentCollision, collection)
    }
}

// Goes through all the collisions of the main bot
// Determines what all bots have to move, and when
Path[][] createPhases(Point from, Point to, ChessPiece[] mainCollisions) {
    Path[][] phases
    loop through mainCollisions -> currentCollision {
        if piece's location isn't the same as *to* {
            Path[][] recursiveCollections
            ChessPiece rootPiece = board[currentCollision.location.x][currentCollision.location.y]
            recursiveCalculateCollision(from, rootPiece, recursiveCollections)

            // recursiveCalculateCollision will modify recursiveCollections
            int difference = length of recursiveCollections - length of phases
            if difference is bigger than 1 {
                increase size of first phase array by difference
            }
            loop through recursiveCollections -> collectionIndex {
                loop through recursiveCollections[collectionIndex] -> loopIndex {
                    add recursiveCollections[collectionIndex][loopIndex] to phases[loopIndex]
                }
            }
        }
    }
    return phases
}

// Takes in all the phases and shifts them out of the way
// Also return the path to move them back
// Shifts bots in phases from outer to inner
Path[][] shiftCollisions(Path[][] phases) {
    Path[][] unshifts
    loop for length of phases' outermost array (number of phases) -> phaseIndex {
        Path phaseMoves = phases[phaseIndex]
        moveMultipleBots(phaseMoves)
        loop through phaseMoves -> pathIndex {
            Path invertedPath = invert the horizontal and vertical in phase to get the path back
            add invertedPath to unshifts[phaseIndex][pathIndex]
        }
    }
    return unshifts
}

// Takes an array of paths for the shifted bots and move them back
// Unshifts bots in phases from inner to outer
void unshiftCollisions(Path[][] unshifts) {
    loop in reverse for length of unshift's outermost array (number of phases) -> loopIndex {
        Path phaseMoves = unshifts[loopIndex]
        moveMultipleBots(phaseMoves)
    }
}

// Takes in a path object
// Bot should first move horizontally, then move vertically
void moveSingleBot(Path path) {
    This will require a lot of communication testing before psuedo code can be written
}

// Takes in an array of path objects and moves all of them at once
void moveMultipleBots(Path[] paths) {
    This will require a lot of communication testing before psuedo code can be written
}

// Once a taken piece is in the dead zone, this will send a signal to the bot to leave towards the collection zone
void sendLeaveSignal(ChessPiece bot) {
    This will require a lot of communication testing before psuedo code can be written
}

// After player or ai move from server.js, this will run (the move is guaranteed valid)
// Calls all the functions to move the bot and update its position without collisions
void sendMove(String stringFrom, String stringTo) {
    botsMoving = true
    bool capture = false
    Point from = convertStringToPoint(stringFrom)
    Point to = convertStringToPoint(stringTo)
    ChessPiece captureSpot = board[to.x][to.y]
    if captureSpot isn't empty {
        capture = true
    }
    Path path = calculatePath(from, to)
    ChessPiece[] mainCollisions = calculateAllCollisions(path)
    ChessPiece[][] phases = createPhases(from, to, mainCollisions)
    Path[] unshifts = shiftCollisions(phases)
    moveSingleBot(path)
    unshiftCollisions(unshifts)
    if capture is true {
        sendLeaveSignal(captureSpot)
    }
    updateMatrix(from, to)
    botsMoving = false
}